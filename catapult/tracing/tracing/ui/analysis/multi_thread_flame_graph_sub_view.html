<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/ui/analysis/analysis_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/multi_event_sub_view.html">
<link rel="import" href="/tracing/ui/analysis/related_events.html">
<link rel="import" href="/tracing/ui/base/tracecompare.html">

<polymer-element name="tr-ui-a-multi-thread-flame-graph-sub-view">
  <template>
    <style>
    :host {
      display: flex;
    }
    #content {
      display: flex;
      flex: 1 1 auto;
    }
    #content > #right > tr-ui-a-related-events {
      margin-left: 8px;
      flex: 0 1 200px;
    }
    #flame-graph-button {
      background-color: orange;
      border-color: orange;
      color: #4d0000;
      margin: 0 auto;
      text-align: center;
      width: 75%;
    }
    #flamegraph_wrapper {
      background-color: orange;
      display: block;
      flex: 1 1 auto;
    }
	
	/* Flame graph */
	svg#flamegraph {
		margin-top:15px;
		width: 100%;
		font-size: 0.9em;
	}

	svg#flamegraph g.inv {
	  display:none;
	}
	
    #flamegraph {
      display: flex;
      flex: 1 1 auto;
    }
	
	svg#flamegraph rect {
		fill: #EEEEEE;
		stroke: #D6D6D6;
	}
	
	/* Selected function */
	#selected-function
	{
	  border: 1px solid #D6D6D6;
	  border-radius: 2px;
	  padding: 0.5em;
	  margin-top: 0.5em;
	  margin-bottom: 0.5em;
	}

	#selected-function #selected-function-name
	{
	  display:block;
	  margin-right:100px;
	}

	#selected-function #selected-function-links
	{
	  position:absolute;
	  right: 20px;
	}
    </style>
    <div id="flamegraph_wrapper">
        <svg id="flamegraph"></svg>
		
		<div id="selected-function">

			<span id="selected-function-name">&nbsp;</span>
		</div>
    </div>
	
	

  </template>

  <script>
  'use strict';

  Polymer({
    created: function() {
      this.brushingStateController_ = undefined;
      this.selection_ = undefined;
    },
    
    get brushingStateController() {
      return this.brushingStateController_;
    },
    
    set brushingStateController(brushingStateController) {
      this.brushingStateController_ = brushingStateController;
    },

    get selection() {
      return this.selection_;
    },
    
    set selection(selection) {
      this.selection_ = selection;
      
      var fgContainer = d3.select(this.$.flamegraph_wrapper).selectAll('#flamegraph');
	  var selected_fct_ctr = d3.select(this.$.flamegraph_wrapper).selectAll('#selected-function');
      tracecompare(this.getSelectionStacks(selection), fgContainer, selected_fct_ctr);
    },
    
    getSelectionStacks: function(selection) {
      var metadata     = selection[0].model.metadata;
      var timeShift    = Math.abs(selection[0].model.timestampShiftToZeroAmount_);
      var timestampMin = Math.floor((selection.bounds.min + timeShift) * 1000);
      var timestampMax = Math.floor((selection.bounds.max + timeShift) * 1000);
      var unfilteredStacks = undefined;
      
      // Find stacks in the metadata
      for (var i = 0; i < metadata.length; ++i) {
        if (metadata[i].name === 'stacks') {
          unfilteredStacks = metadata[i].value;
        }
      }
      if (unfilteredStacks == undefined) return;
      
      // Gather selected tids
      var tidList = {};
      for (var i = 0; i < selection.length; ++i) {
        var tid = selection[i].parentContainer.tid;
        if (!tidList.hasOwnProperty(tid))
          tidList[tid] = true;
      }
      
      // Keep only the stacks from the selected tids
      var tidFilteredStacks = [];
      for (var tid in tidList) {
        tidFilteredStacks = tidFilteredStacks.concat(unfilteredStacks[tid]);
      }
      
      var fullyFilteredStacks = [];
      for (var i = 0; i < tidFilteredStacks.length; ++i) {
        var actualStack = tidFilteredStacks[i];
        if (actualStack.begin + actualStack.duration < timestampMin) continue;
        if (actualStack.begin > timestampMax) continue;
        
        fullyFilteredStacks.push(actualStack);
      }
      
      var executions = [];
      var samples    = {};
      var stacks     = {};
      
      var beginTimestamp = Number.MAX_VALUE;
      var fullDuration   = 0;
      for (var i = 0; i < fullyFilteredStacks.length; ++i) {
        var stackLine = fullyFilteredStacks[i];
        samples[stackLine.id] = stackLine.duration;
        stacks[stackLine.id]  = {"b":stackLine.parent, "f":stackLine.name};
        
        if (stackLine.begin < beginTimestamp)
          beginTimestamp = stackLine.begin;
        
        if (stackLine.parent == 0)
          fullDuration += stackLine.duration;
      }
      
      executions.push({"a":fullDuration, "b":beginTimestamp, "e":1, "f":1, "g":1, "h":1, "samples":samples});
      
      return {"executions":executions, "stacks":stacks};
      //return {
	  //  "executions":[{"a":18055,"b":1424810701430206,"e":17997,"f":22,"g":26,"h":9,"samples":{"541":18055,"543": 12707, "548": 4289, "549": 4289, "550": 4289, "551": 4076}}],
	  //  "stacks":{"541":{"b":0,"f":"[thread]"},"543":{"b":541,"f":"sys:read"},"548":{"b":541,"f":"__libc_start_main"},"549":{"b":548,"f":"main"},"550":{"b":549,"f":"DoSomeDonkeys(RandomStringGenerator&, mongo::DBClientConnection&)"},"551":{"b":550,"f":"GenerateSomeData(RandomStringGenerator&, mongo::BSONObjBuilder&)"}}
      //};
    },
  });
  </script>
</polymer-element>
